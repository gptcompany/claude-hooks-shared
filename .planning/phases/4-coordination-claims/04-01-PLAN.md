---
phase: 04-coordination-claims
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [hooks/coordination/__init__.py, hooks/coordination/file_claim.py, hooks/coordination/file_release.py]
autonomous: true
---

<objective>
Implement file-level coordination hooks for Write/Edit/MultiEdit tools.

Purpose: Prevent file conflicts when multiple agents work in parallel. File claims are acquired before edit, released after, with broadcast notification.

Output: `hooks/coordination/file_claim.py` (PreToolUse) and `hooks/coordination/file_release.py` (PostToolUse)
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/4-coordination-claims/4-RESEARCH.md
@.planning/phases/4-coordination-claims/4-CONTEXT.md

# Existing patterns to follow:
@/media/sam/1TB/claude-hooks-shared/hooks/core/mcp_client.py
@/media/sam/1TB/claude-hooks-shared/hooks/intelligence/trajectory_tracker.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create coordination hooks directory and __init__.py</name>
  <files>hooks/coordination/__init__.py</files>
  <action>
Create `hooks/coordination/` directory if not exists.
Create `__init__.py` with module docstring explaining coordination purpose.
Follow existing hooks directory pattern (see hooks/intelligence/__init__.py).
  </action>
  <verify>ls -la hooks/coordination/ shows __init__.py exists</verify>
  <done>hooks/coordination/ directory created with __init__.py</done>
</task>

<task type="auto">
  <name>Task 2: Implement file_claim.py (PreToolUse hook)</name>
  <files>hooks/coordination/file_claim.py</files>
  <action>
Create PreToolUse hook for Write|Edit|MultiEdit tools.

Follow trajectory_tracker.py pattern:
- Use argparse for --event argument
- Read hook_input from stdin as JSON
- Return JSON to stdout

Logic:
1. Extract file_path from hook_input["tool_input"]
2. Normalize path with os.path.abspath()
3. Generate session_id (use existing pattern from trajectory_tracker or generate UUID)
4. Call claude-flow claims_claim via subprocess (npx claude-flow claims claim --issueId "file:{path}" --claimant "agent:{session_id}:editor")
5. If claim fails (file already claimed):
   - Return {"decision": "block", "reason": "File claimed by {existing_claimant}"}
6. If claim succeeds:
   - Store claimed file path in session state file (for later release)
   - Return {} (allow edit to proceed)

Use mcp_client.py pattern for subprocess calls.
Timeout: 5 seconds max.
Log to /tmp/claude-metrics/coordination.log
  </action>
  <verify>python3 hooks/coordination/file_claim.py --help shows usage</verify>
  <done>file_claim.py created, reads stdin JSON, returns claim result</done>
</task>

<task type="auto">
  <name>Task 3: Implement file_release.py (PostToolUse hook)</name>
  <files>hooks/coordination/file_release.py</files>
  <action>
Create PostToolUse hook for Write|Edit|MultiEdit tools.

Logic:
1. Extract file_path from hook_input["tool_input"]
2. Normalize path with os.path.abspath()
3. Load session_id from state file (same as file_claim.py)
4. Call claude-flow claims_release via subprocess
5. Call claude-flow hooks_notify to broadcast file release:
   - message: "File released: {file_path}"
   - target: "all"
   - data: {"file": file_path, "event": "release"}
6. Remove file from session state (claimed files list)
7. Return {} (no output modification needed)

Handle errors gracefully - don't break session if release fails.
Log success/failure to coordination.log
  </action>
  <verify>python3 hooks/coordination/file_release.py --help shows usage</verify>
  <done>file_release.py created, releases claim and broadcasts notification</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] hooks/coordination/__init__.py exists
- [ ] hooks/coordination/file_claim.py is executable (chmod +x)
- [ ] hooks/coordination/file_release.py is executable (chmod +x)
- [ ] Both hooks accept JSON from stdin without error
- [ ] Both hooks return valid JSON to stdout
</verification>

<success_criteria>
- All tasks completed
- File claim hook blocks on already-claimed files
- File release hook broadcasts notification
- Hooks follow existing codebase patterns
</success_criteria>

<output>
After completion, create `.planning/phases/4-coordination-claims/04-01-SUMMARY.md`
</output>
